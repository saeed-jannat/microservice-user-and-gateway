microservice-user-and-gateway

This repository contains a production-oriented microservices-based backend project designed to demonstrate modern backend architecture,
advanced authorization, and real-world access control scenarios commonly used in accounting systems, ERP platforms, and multi-tenant SaaS products.

The project focuses on solving complex authorization problems rather than showcasing a large number of technologies.

Architecture Overview

The system consists of two main components:

1. User Service

The User Service is responsible for managing users and a custom-built authorization system implemented entirely from scratch.

It handles:

Authentication and registration

Claims and profile management

Role and permission management

Organization, company, and zone separation

Context-aware access control

The service is designed for multi-tenant environments, where access rules vary by company, role, user, and financial year.

2. API Gateway

The API Gateway, built using Ocelot, acts as the single entry point for all client requests.

Responsibilities include:

Routing requests to appropriate microservices

Centralized authentication handling

Service isolation

Configuration-driven routing for scalability

Ocelot provides a clean and flexible approach for managing service-to-service communication in a microservices architecture.

Core Features
üîê Advanced Authorization System (Built from Scratch)

This project goes far beyond basic Role-Based Access Control (RBAC) and implements a fine-grained, context-aware authorization model.

Role & Permission Management

Roles are defined per company

Each role has a dedicated set of permissions

Users can be assigned multiple roles

User-Level Permission Overrides

Permissions inherited from roles can be:

Extended

Restricted

Effective permissions are dynamically calculated per user

This enables fine-grained access control at the individual user level.

üß† Context-Based Authorization (Financial Year)

Authorization is not global.

Permissions are evaluated per financial year

A user may have access to one year while being restricted from another

This model reflects real-world requirements in accounting and financial systems.

üè¢ Multi-Tenant (Company-Isolated) Access

Each company is fully isolated

Roles, permissions, and users are scoped per company

Cross-company access is strictly controlled

This design supports real-world multi-tenant SaaS architectures.

‚ö° Authorization Caching Strategy

To avoid expensive permission resolution on every request, the system includes a custom-built caching mechanism.

Permission Caching

Role permissions are cached immediately after creation

User effective permissions are resolved once and reused

Cached data includes:

Role permissions

User-level permission overrides

Context data (company and financial year)

Cache Invalidation

Cache entries are automatically invalidated and rebuilt when:

Role permissions are modified

User-role assignments change

User-specific permission overrides are updated

Design Considerations

Caching logic is implemented independently of any specific caching technology

Designed to be easily replaceable with a distributed cache (e.g. Redis) without changing core authorization logic

This approach prioritizes correctness, performance, and maintainability.

üß± Microservices Architecture

Independent and loosely coupled services

Clear separation of responsibilities

Scalable and maintainable design

üîë Secure Authentication

JWT-based authentication

Private keys are stored securely using:

Docker secrets or volumes

No hardcoded secrets

üê≥ Containerization

Fully Dockerized services

Easy local and production-like deployments

Infrastructure-friendly setup

üóÑ Data Storage

SQL Server

Designed for reliability and performance

Structured schema suitable for enterprise workloads

Technologies Used

.NET / ASP.NET Core

Ocelot (API Gateway)

Docker

SQL Server

JWT (JSON Web Tokens)

Running the Project
Prerequisites

.NET SDK

Docker (optional)

SQL Server

Setup Instructions

Create database tables using the provided schema

Configure a secret or volume for the JWT private key

Ensure the services read the private key from the configured source

If running without Docker, simply run the projects normally after configuration.

Use Cases

This project is suitable for:

Accounting systems

ERP platforms

Multi-tenant SaaS products

Systems requiring fine-grained and context-aware authorization

Developers looking to study real-world backend authorization patterns

Notes

This project is not a tutorial-only demo.
It reflects real authorization challenges commonly found in production systems and demonstrates how they can be solved cleanly using .NET and microservices.
